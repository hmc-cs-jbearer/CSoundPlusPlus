from mido import MidiFile, MidiTrack, Message, MetaMessage

def readFile(path):
    return MidiFile(path)

def deserialize(path):
    lines = []
    for i, track in enumerate(readFile(path).tracks):
        lines.append('Track {}: {}'.format(i, track.name))
        for message in track:
            lines.append(str(message))

    return '\n'.join(lines)

def serialize(path, file):
    file.save(path)

def writeFile(path, type=1):
    file = MidiFile(type=type)

    # Replicate the header generated by MuseScore, which we know is compatible with CSound
    # Some of this may not be necessary, and will be removed if possible in the future
    return FileWriter(path, file) \
        .trackHeader() \
            .meta(Messages.TIME, numerator=4, denominator=4, clocks_per_click=24,
                  notated_32nd_notes_per_beat=8, time=0) \
            .meta(Messages.KEY, key='C', time=0) \
            .meta(Messages.TEMPO, tempo=500000, time=0) \
            .programChange(program=0, time=0) \
            .meta(Messages.PORT, port=0, time=0) \
        .endHeader()

def appendFile(path, type=1):
    try:
        file = MidiFile(path, type=type)
    except:
        file = MidiFile(type=type)
    return FileWriter(path, file)

class Messages:
    '''
    Enumeration of message types
    '''
    END_OF_TRACK = 'end_of_track'
    TIME = 'time_signature'
    KEY = 'key_signature'
    TEMPO = 'set_tempo'
    PORT = 'midi_port'

class TrackWriter:

    class ChannelHeader:

        def __init__(self, parent):
            self._parent = parent
            self._channel = []

        def get(self, c):
            return [message(c) for message in self._channel]

        def controlChange(self, control, value, time):
            print('control change {} {} {}'.format(control,value,time))
            self._channel.append(lambda c: Message(
                'control_change', control=control, value=value, time=time, channel=c))
            return self

        def meta(self, type, **data):
            self._channel.append(lambda c: MetaMessage(type, channel=c, **data))
            return self

        def endHeader(self):
            return self._parent

    class Interpolator:

        def __init__(self, n, parent):
            self._n = n
            self._parent = parent
            self._from = self._parent.get()[-1] if len(self._parent.get()) > 0 \
                else Message('note_on')

        def fromNote(self, note, velocity, duration):
            self._from = Message('note_on', note=note, velocity=velocity, time=duration)
            return self

        def toNote(self, note, velocity, duration):
            def interp(start, end):
                return lambda n: int((float(n) / self._n) * (end - start) + start)
            midNote = interp(self._from.note, note)
            midVel = interp(self._from.velocity, velocity)
            midDur = interp(self._from.time, duration)

            self._parent.notes(
                [midNote(n) for n in range(self._n)],
                [midVel(n) for n in range(self._n)],
                [midDur(n) for n in range(self._n)]
            )

            return self._parent

    def __init__(self, parent):
        self._parent = parent
        self._track = []
        self._channel = 0
        self._channels = []
        self._channelHeader = TrackWriter.ChannelHeader(self)

        # Set things up
        self.channel(self._channel)

    def get(self):
        return self._track

    def channelHeader(self):
        return self._channelHeader

    def channel(self, channelId):
        if 0 < channelId or channelId > 15:
            raise ValueError('MIDI channel must be between 0 and 15.')
        self._channel = channelId
        if self._channel not in self._channels:
            self._channels.append(self._channel)
        return self

    def nextChannel(self):
        return self.channel(self._channel + 1)

    def note(self, note, velocity, duration):

        # Automatically turn off the last note that was played
        lastNote = self._lastNote()
        if lastNote:
            self._noteOff(lastNote)

        # Play a new note
        self._track.append(Message('note_on',
            note=note, velocity=velocity, time=int(duration/2), channel=self._channel))

        return self

    def notes(self, notes, velocities, durations):
        if len(notes) != len(velocities):
            raise ValueError('Wrong number of notes ({}) and velocities ({}).'.format(
                len(notes), len(velocities)))
        if len(velocities) != len(durations):
            raise ValueError('Wrong number of velocities({}) and durations ({}).'.format(
                len(velocities), len(durations)))

        for note, velocity, duration in zip(notes, velocities, durations):
            self.note(note, velocity, duration)

        return self

    def interpolate(self, n):
        return TrackWriter.Interpolator(n, self)

    def rest(self, duration):
        if len(self._track) == 0:
            self._track.append(Message('note_on', velocity=0, time=duration))
            return self

        lastMessage = self._track[-1]
        if lastMessage.type == 'note_on':
            # If there is currently a note on, turn it off and hold for the specified duration
            self._noteOff(lastMessage)
            self._track.append(Message('note_on', velocity=0, time=duration))
        else:
            # If there is no note on, just hold off for a little longer
            lastMessage.time += duration

        return self

    def controlChange(self, control, value, time):
        self._track.append(Message('control_change',
            control=control, value=value, time=time, channel=self._channel))
        return self

    def programChange(self, program, time):
        self._track.append(Message('program_change',
            program=program, time=time, channel=self._channel))
        return self

    def meta(self, type, **data):
        self._track.append(MetaMessage(type, **data))
        return self

    def track(self, track, channel=0):
        return self._parent.track(track, channel=channel)

    def nextTrack(self, channel=0):
        return self._parent.nextTrack(channel=channel)

    def finalize(self):
        for channel in self._channels:
            self.channel(channel)
            lastNote = self._lastNote()
            if lastNote:
                self._noteOff(lastNote)
            self._track = self._channelHeader.get(channel) + self._track

        self.meta(Messages.END_OF_TRACK, time=1)

        return self

    def end(self):
        return self._parent.end()

    def _noteOff(self, noteOnMsg):
        # Instead of a note_off message, CSound requires a note_on with v=0.
        # I have absolutely no idea why.
        self._track.append(Message('note_on',
            note=noteOnMsg.note, velocity=0, time=noteOnMsg.time, channel=noteOnMsg.channel))

    def _lastNote(self):
        for message in self._track[::-1]:
            if message.type == 'note_on' and message.channel == self._channel:
                return message
        return None

class FileWriter:
    '''
    A convenience class for writing MIDI files. This provides an elegant method-chaining API, and
    allows the client to easily write files consisting of multiple tracks, where each track is
    monophonic.
    '''

    class TrackHeader(TrackWriter):

        def __init__(self, parent):
            TrackWriter.__init__(self, parent)

        def endHeader(self):
            return self._parent.track(self._parent._track)

    def __init__(self, path, file):
        self._file = file
        self._path = path
        self._track = 0
        self._tracks = []
        self._trackHeader = FileWriter.TrackHeader(self)

        # Set things up
        self.track(self._track)

    def trackHeader(self):
        return self._trackHeader

    def track(self, trackId, channel=0):
        # Make sure we actually have enough tracks
        while len(self._tracks) <= trackId:
            self._tracks.append(TrackWriter(self))
        self._tracks[trackId].channel(channel)
        self._track = trackId
        return self._getTrack()

    def nextTrack(self, channel=0):
        return self.track(self._track + 1, channel=channel)

    def channel(self, channelId):
        return self._getTrack().channel(channelId)

    def nextChannel(self):
        return self._getTrack().nextChannel()

    def end(self):
        self._trackHeader.finalize()
        for (i, track) in enumerate(self._tracks):
            track.finalize()
            while i >= len(self._file.tracks):
                self._file.tracks.append([])
            self._file.tracks[i] = self._trackHeader.get() + self._file.tracks[i] + track.get()

        serialize(self._path, self._file)

        # End of chaining
        return None

    def _getTrack(self):
        return self._tracks[self._track]
